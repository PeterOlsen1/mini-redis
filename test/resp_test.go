package miniredis_test

import (
	"mini-redis/resp"
	"reflect"
	"testing"
)

// generated by AI but reveiewed by me

func TestRESP_SerializeAndDecode(t *testing.T) {
	type testCase struct {
		name      string
		value     any
		valueType resp.RespType
		encoded   []byte
		decoded   any
		decType   resp.RespType
		shouldErr bool
	}

	tests := []testCase{
		{
			name:      "Simple String",
			value:     "OK",
			valueType: resp.STRING,
			encoded:   []byte("+OK\r\n"),
			decoded:   "OK",
			decType:   resp.STRING,
		},
		{
			name:      "Error",
			value:     "something failed",
			valueType: resp.ERR,
			encoded:   []byte("-ERR something failed\r\n"),
			decoded:   "something failed",
			decType:   resp.ERR,
		},
		{
			name:      "Null",
			value:     nil,
			valueType: resp.NULL,
			encoded:   []byte("_\r\n"),
			decoded:   nil,
			decType:   resp.NULL,
		},
		{
			name:      "Bulk String",
			value:     "foobar",
			valueType: resp.BULK_STRING,
			encoded:   []byte("$6\r\nfoobar\r\n"),
			decoded:   "foobar",
			decType:   resp.BULK_STRING,
		},
		{
			name:      "Array of Bulk Strings",
			value:     []string{"foo", "bar"},
			valueType: resp.ARRAY,
			encoded:   []byte("*2\r\n$3\r\nfoo\r\n$3\r\nbar\r\n"),
			decoded:   []string{"foo", "bar"},
			decType:   resp.ARRAY,
		},
	}

	for _, tc := range tests {
		t.Run("Serialize "+tc.name, func(t *testing.T) {
			got, err := resp.Serialize(tc.value, tc.valueType)
			if tc.shouldErr {
				if err == nil {
					t.Fatalf("expected error, got nil")
				}
				return
			}
			if err != nil {
				t.Fatalf("unexpected error: %v", err)
			}
			if string(got) != string(tc.encoded) {
				t.Errorf("Serialize: got %q, want %q", got, tc.encoded)
			}
		})

		t.Run("Decode "+tc.name, func(t *testing.T) {
			val, typ, err := resp.Decode(tc.encoded)
			if tc.shouldErr {
				if err == nil {
					t.Fatalf("expected error, got nil")
				}
				return
			}
			if err != nil {
				t.Fatalf("unexpected error: %v", err)
			}
			if typ != tc.decType {
				t.Errorf("Decode: got type %v, want %v", typ, tc.decType)
			}
			switch v := tc.decoded.(type) {
			case []string:
				gotArr, ok := val.([]string)
				if !ok || !reflect.DeepEqual(gotArr, v) {
					t.Errorf("Decode: got %v, want %v", val, v)
				}
			default:
				if val != v {
					t.Errorf("Decode: got %v, want %v", val, v)
				}
			}
		})
	}

	t.Run("Decode empty input", func(t *testing.T) {
		_, _, err := resp.Decode([]byte{})
		if err == nil {
			t.Error("expected error for empty input")
		}
	})

	t.Run("Decode invalid type", func(t *testing.T) {
		_, _, err := resp.Decode([]byte("!invalid\r\n"))
		if err == nil {
			t.Error("expected error for invalid type")
		}
	})

	t.Run("Serialize invalid array type", func(t *testing.T) {
		_, err := resp.Serialize(123, resp.ARRAY)
		if err == nil {
			t.Error("expected error for invalid array type")
		}
	})

	t.Run("Serialize invalid bulk string type", func(t *testing.T) {
		_, err := resp.Serialize(123, resp.BULK_STRING)
		if err == nil {
			t.Error("expected error for invalid bulk string type")
		}
	})
}
